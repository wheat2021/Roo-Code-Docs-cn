---
title: MCP 与 API 对比
sidebar_label: MCP 与 API 对比
---

# MCP 与 REST API：根本区别

将 REST API 与模型上下文协议（MCP）进行比较是一种分类错误。它们在不同的抽象层上运行，并在人工智能系统中服务于根本不同的目的。

---

## 架构差异

| 特性 | MCP | REST API |
|---|---|---|
| 状态管理 | **有状态** - 在交互中维护上下文 | **无状态** - 每个请求都是独立的 |
| 连接类型 | 持久的双向连接 | 单向的请求/响应 |
| 通信风格 | 基于 JSON-RPC 的持续会话 | 基于 HTTP 的离散请求 |
| 上下文处理 | 上下文是协议固有的 | 必须手动管理上下文 |
| 工具发现 | 运行时发现可用工具 | 设计时集成，需要先验知识 |
| 集成方法 | 具有动态能力的运行时集成 | 需要代码更改的设计时集成 |

---

## 不同层次，不同目的

REST API 和 MCP 服务于技术栈中的不同层级：

1.  **REST**：暴露资源操作的低级 Web 通信模式
2.  **MCP**：协调工具使用并维护上下文的高级 AI 协议

MCP 内部通常使用 REST API，但为 AI 抽象了它们。可以将 MCP 视为中间件，它将离散的 Web 服务转变为一个 AI 可以在其中运行的内聚环境。

---

## 上下文保留：对 AI 工作流至关重要

MCP 的有状态设计解决了 REST 在 AI 应用中的一个关键限制：

-   **REST 方法**：每个调用都是隔离的，需要在步骤之间手动传递上下文
-   **MCP 方法**：一个对话上下文在多个工具使用中持续存在

例如，一个调试代码库的 AI 可以打开文件、运行测试并识别错误，而不会在步骤之间丢失上下文。MCP 会话保持对先前操作和结果的感知。

---

## 动态工具发现

MCP 使 AI 能够在运行时发现和使用工具：

```json
// AI 发现可用工具
{
  "tools": [
    {
      "name": "readFile",
      "description": "从文件中读取内容",
      "parameters": {
        "path": { "type": "string", "description": "文件路径" }
      }
    },
    {
      "name": "createTicket",
      "description": "在问题跟踪器中创建工单",
      "parameters": {
        "title": { "type": "string" },
        "description": { "type": "string" }
      }
    }
  ]
}
```

这种“即插即用”的能力允许在不重新部署或修改 AI 本身的情况下添加新工具。

---

## 真实世界示例：多工具工作流

考虑一个需要多个服务的任务：“检查最近的提交，为错误修复创建一个 JIRA 工单，并发布到 Slack。”

**基于 REST 的方法**：
- 需要为 Git、JIRA 和 Slack API 进行单独集成
- 需要自定义代码来管理调用之间的上下文
- 如果任何服务更改其 API，则会中断

**基于 MCP 的方法**：
- 所有工具的统一协议
- 在整个工作流中维护上下文
- 无需更改代码即可换入新工具

---

## Roo Code 为何使用 MCP

Roo Code 利用 MCP 提供：

1.  **可扩展性**：添加无限的自定义工具，无需等待官方集成
2.  **上下文感知**：工具可以访问对话历史和项目上下文
3.  **简化集成**：一个标准协议，而不是众多 API 模式
4.  **运行时灵活性**：即时发现和使用新功能

MCP 在 Roo Code 和外部服务之间创建了一个通用连接器，而 REST API 通常在幕后为这些服务提供支持。

---

## 结论：互补而非竞争的技术

MCP 不会取代 REST API——它建立在它们之上。REST 擅长提供离散服务，而 MCP 擅长为 AI 代理协调这些服务。

关键区别在于 MCP 是 AI 原生的：它将模型视为一等用户，提供 AI 代理在复杂环境中有效运作所需的上下文、有状态的交互层。