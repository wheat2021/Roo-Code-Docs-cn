# attempt_completion

`attempt_completion` 工具标志着 Roo 认为任务已完成，并向用户展示结果。它总结了已完成的工作，可选择性地包含一个命令来演示结果，并支持通过用户反馈进行持续优化。

---

## 参数

该工具接受以下参数：

- `result` (必需): 最终结果的描述，总结已完成的工作。
- `command` (可选): 用于演示结果的命令行界面（CLI）命令。

---

## 功能

此工具通过呈现已完成工作的最终摘要来标记任务的结束。它向用户和系统发出信号，表明当前任务已完成。当提供命令时，它还可以通过实时执行来演示结果。

---

## 使用时机

- 当 Roo 认为用户的任务已经完成时。
- 当需要总结所做的更改或改进时。
- 当需要通过执行命令来演示当前结果时。
- 当为用户反馈解决方案提供一个检查点时。
- 当从一个工作阶段过渡到可能的优化阶段时。

---

## 主要特性

- 提供一个明确的信号，表明 Roo 认为任务已完成。
- 用简洁的消息总结所取得的成就。
- 可选择通过执行命令来演示结果。
- 支持用户反馈以进行进一步的优化。
- 以区别于常规消息的特殊 UI 格式显示结果。
- 捕获任务完成的遥测数据用于系统分析。
- 通过提供检查点来维持结构化的对话流程。
- 支持在更庞大的工作流中完成子任务。
- 确保用户收到关于已完成工作的清晰摘要。
- 作为“始终可用”工具组的一部分，在所有模式下都可用。

---

## 限制

- 在确认先前的工具使用成功之前不应使用（此为指导原则，非强制）。
- 仅限于使用单个命令来演示结果。
- 无法提供多个命令选项。
- 命令执行前需要用户批准。
- 仅限于演示可通过 CLI 命令显示的结果。
- 不能用于部分任务完成或进度更新。
- 结果格式化会通过内部处理剥离 XML 闭合标签。

---

## 工作原理

当调用 `attempt_completion` 工具时，它会遵循以下流程：

1.  **安全考量** (指导原则，非强制):
    -   AI 被指示要确认之前的工具使用是成功的。
    -   这是一种最佳实践，而不是一个程序上强制执行的机制。

2.  **结果呈现**:
    -   以特殊的 "completion_result" UI 格式向用户显示完成消息。
    -   使用 `removeClosingTag` 函数从结果文本中移除 XML 闭合标签。
    -   以不同于常规消息的方式呈现结果，以示视觉区别。

3.  **命令执行** (如果提供):
    -   在执行命令前请求用户批准。
    -   仅在用户批准后执行。
    -   使用系统的命令执行功能来执行命令。
    -   向用户显示命令的执行结果。

4.  **反馈收集**:
    -   等待用户对完成结果的反馈。
    -   处理此反馈并将其返回给 AI。
    -   根据用户输入进行持续优化。

5.  **任务完成与继续**:
    -   在系统中将任务标记为已完成。
    -   为已完成的任务捕获遥测数据。
    -   对于子任务，提供完成子任务并恢复父任务的选项。
    -   通过反馈机制支持持续对话。

6.  **实现集成**:
    -   工具结果通过系统在 `parse-assistant-message.ts` 中的解析机制进行解析。
    -   该工具是 `ALWAYS_AVAILABLE_TOOLS` 常量的一部分，使其在所有模式下都可用。

---

## 结果格式化指南

结果消息应遵循以下指南：

-   清晰地传达已完成的工作。
-   简洁但完整。
-   专注于为用户带来的价值。
-   避免不必要的客套话或填充文本。
-   保持专业、直接的语气。
-   以易于浏览和理解的方式呈现信息。
-   承认用户可能会为进一步的优化提供反馈。

注意：系统会通过 `removeClosingTag` 函数自动从结果文本中剥离 XML 闭合标签。

---

## 命令选择指南

在包含命令时，请遵循以下指南：

-   选择能够直观演示结果的命令。
-   优先选择能向用户展示创建或修改了什么的命令。
-   示例包括：
    -   `open index.html` 来显示创建的网站。
    -   `npm start` 来启动开发服务器。
    -   `python app.py` 来运行创建的应用程序。
-   避免仅打印文本的命令 (如 `echo` 或 `cat`)。
-   记住命令在执行前需要用户批准。
-   确保命令对用户的操作系统有效。

---

## 反馈与 UI 表示

`attempt_completion` 工具具有独特的反馈机制：

-   结果以特殊的 "completion_result" UI 格式显示，区别于常规消息。
-   系统在呈现结果后等待用户反馈。
-   反馈被处理并返回给 Roo 以进行进一步的优化。
-   这创建了一个迭代改进的循环，而不是结束对话。
-   UI 包含用于提供反馈的特殊元素。
-   结果在对话流程中作为清晰的检查点。

在子任务中使用时：
-   系统提供完成子任务并恢复父任务的选项。
-   如果获得批准，子任务将以摘要形式完成。
-   父任务将带着已完成子任务的上下文恢复。
-   这使得在保持上下文的同时能够实现复杂的嵌套工作流。

---

## 使用场景示例

-   创建网站时，Roo 呈现解决方案并使用 `open index.html` 来展示结果。用户提供反馈，Roo 对设计进行优化。
-   实现功能时，Roo 总结更改及其影响。用户要求增加测试覆盖率，Roo 继续执行任务。
-   修复错误时，Roo 解释修复了什么以及解决方案如何解决根本原因。用户确认修复有效。
-   设置开发环境时，Roo 确认所有组件都已安装。用户要求进行额外配置，Roo 继续操作。
-   创建数据处理脚本时，Roo 总结其功能。用户建议性能改进，Roo 优化代码。

---

## 用法示例


仅用结果摘要完成任务：
```
<attempt_completion>
<result>
我已更新导航栏的 CSS 以匹配设计模型。更改包括：
1. 更新了配色方案以使用新的品牌颜色
2. 为移动设备添加了响应式行为
3. 修复了下拉菜单中的对齐问题
</result>
</attempt_completion>
```

用结果和演示命令完成任务：
```
<attempt_completion>
<result>
我创建了一个简单的 React 应用程序，具有以下功能：
1. 一个带有要求的英雄部分的响应式登录页面
2. 一个带验证功能的工作联系表单
3. 在所有三个要求的页面之间进行导航
4. 与提供的设计模型相匹配的样式
</result>
<command>npm start</command>
</attempt_completion>
```

完成一个 Python 脚本任务并执行：
```
<attempt_completion>
<result>
我创建了一个数据处理脚本，该脚本：
1. 从数据目录中读取 CSV 文件
2. 按要求清洗和规范化数据
3. 以 JSON 格式生成摘要统计信息
4. 将处理后的数据输出到输出目录
</result>
<command>python process_data.py</command>
</attempt_completion>
