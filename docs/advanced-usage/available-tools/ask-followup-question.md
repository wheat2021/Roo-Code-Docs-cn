# ask_followup_question

`ask_followup_question` 工具通过提出具体问题来收集有效完成任务所需的额外信息，从而实现交互式沟通。

---

## 参数

该工具接受以下参数：

- `question` (必需): 要向用户提出的具体问题。
- `follow_up` (可选): 一个包含 2-4 个建议答案的列表，用于引导用户回应，每个建议答案都包含在 `<suggest>` 标签内。

---

## 功能

该工具在 Roo 和用户之间创建了一个对话界面，用于在遇到模糊不清或需要决策时，收集澄清信息、额外细节或用户偏好。每个问题都可以包含建议的回答，以简化交互过程。

---

## 使用时机

- 当原始请求中缺少关键信息时。
- 当 Roo 需要在多种有效的实现方法之间做出选择时。
- 当需要技术细节或偏好才能继续进行时。
- 当 Roo 遇到需要解决的模糊问题时。
- 当额外的上下文能显著提高解决方案质量时。

---

## 主要特性

- 提供一种结构化的方式来收集特定信息，而不会中断工作流程。
- 包含建议答案，以减少用户输入并引导回应。
- 在多次交互中保持对话历史和上下文。
- 支持包含图片和代码片段的回答。
- 作为“始终可用”工具集的一部分，在所有模式下均可使用。
- 允许用户直接指导实现决策。
- 使用 `<answer>` 标签格式化回答，以区别于常规对话。
- 成功使用后会重置连续错误计数器。

---

## 限制

- 每次工具使用仅限提出一个具体问题。
- 在用户界面中将建议显示为可选项。
- 无法强制结构化回答——用户仍然可以自由回答。
- 过度使用会减慢任务完成速度，并造成碎片化的体验。
- 建议的答案必须是完整的，不能有需要用户编辑的占位符。
- 对用户回答没有内置验证。
- 没有强制特定回答格式的机制。

---

## 工作原理

当调用 `ask_followup_question` 工具时，它会遵循以下流程：

1.  **参数验证**: 验证必需的 `question` 参数，并检查可选的建议。
    -   确保提供了问题文本。
    -   使用 `fast-xml-parser` 库解析 `follow_up` 参数中的任何建议答案。
    -   即使只有一个建议，也将其规范化为数组格式。

2.  **JSON 转换**: 将 XML 结构转换为标准化的 JSON 格式，以便在 UI 中显示。
    ```typescript
    {
      question: "用户的问题在此",
      suggest: [
        { answer: "建议 1" },
        { answer: "建议 2" }
      ]
    }
    ```

3.  **UI 集成**:
    -   通过 `ask("followup", ...)` 方法将 JSON 结构传递给 UI 层。
    -   在界面中向用户显示可选择的建议按钮。
    -   创建用于选择或输入回答的交互式体验。

4.  **回答收集与处理**:
    -   捕获用户文本输入以及回答中包含的任何图片。
    -   在返回给助手时，将用户回答用 `<answer>` 标签包裹。
    -   保留用户回答中包含的任何图片。
    -   通过将回答添加到历史记录来维护对话上下文。
    -   当工具成功使用时，重置连续错误计数器。

5.  **错误处理**:
    -   使用计数器跟踪连续错误。
    -   当工具成功使用时，重置计数器。
    -   提供特定的错误消息：
        -   对于缺失参数：“Missing required parameter 'question'”
        -   对于 XML 解析：“Failed to parse operations: [error message]”
        -   对于无效格式：“Invalid operations xml format”
    -   包含防止在缺少必需参数时执行工具的保障措施。
    -   发生错误时增加连续错误计数。

---

## 工作流程序列

问答周期遵循以下顺序：

1.  **识别信息差距**: Roo 识别出继续进行所需的缺失信息。
2.  **创建具体问题**: Roo 制定一个清晰、有针对性的问题。
3.  **制定建议**: Roo 创建相关的建议答案（可选但推荐）。
4.  **调用工具**: 助手使用问题和可选建议调用该工具。
5.  **UI 展示**: 问题和建议作为交互元素显示给用户。
6.  **用户回答**: 用户选择一个建议或提供自定义答案。
7.  **消息处理**: 系统处理部分和完整的消息。
    -   对于流式响应，在到达时处理数据块。
    -   对于完整的消息，一次性处理整个响应。
    -   无论消息分块如何，都保持状态一致性。
8.  **回答处理**: 系统将回答用 `<answer>` 标签包裹并保留图片。
9.  **上下文集成**: 回答被添加到对话历史中。
10. **任务继续**: Roo 使用新信息继续执行任务。

---

## 使用示例

-   在开发 Web 应用程序时，Roo 可能会询问首选的样式框架（Bootstrap、Tailwind、自定义 CSS）。
-   在创建 API 时，Roo 可能会询问身份验证方法（JWT、OAuth、API 密钥）。
-   在重构代码时，Roo 可能会询问是优先考虑性能还是可读性。
-   在设置数据库时，Roo 可能会询问具体的模式设计偏好。
-   在创建自定义功能时，Roo 可能会询问具体的行为期望。
-   在排查错误时，Roo 可能会询问具体的环境细节。

---

## 回答格式

当用户回答问题时，回答会用 `<answer>` 标签进行格式化，以确保清晰和一致。这种格式有助于将用户的答案与其他对话元素明确分开。

回答格式示例：
```
<answer>
使用 Tailwind CSS 实现工具优先的样式，以获得最大的灵活性。
</answer>
```

回答格式的主要特点：
-   由 `<answer>` 标签包裹。
-   保留原始回答的格式。
-   如果回答中包含图片，则保留图片。
-   即使是长回答，也返回完整的文本。

---

## 用法示例

询问实现偏好：
```
<ask_followup_question>
<question>对于这个 Web 应用程序，您希望采用哪种样式方法？</question>
<follow_up>
<suggest>使用 Bootstrap 以便通过一致的组件进行快速开发</suggest>
<suggest>使用 Tailwind CSS 实现工具优先的样式，以获得最大的灵活性</suggest>
<suggest>使用原生 CSS 进行自定义样式，以实现完全控制和最少的依赖</suggest>
</follow_up>
</ask_followup_question>
```


请求技术澄清：
```
<ask_followup_question>
<question>此应用程序应使用哪个数据库来存储用户数据？</question>
<follow_up>
<suggest>MongoDB，用于灵活的模式和基于文档的存储</suggest>
<suggest>PostgreSQL，用于具有强一致性保证的关系数据</suggest>
<suggest>Firebase，用于实时更新和简化的后端管理</suggest>
<suggest>SQLite，用于轻量级本地存储，无外部依赖</suggest>
</follow_up>
</ask_followup_question>
```

解决需求中的模糊之处：
```
<ask_followup_question>
<question>应用程序应如何处理用户身份验证？</question>
<follow_up>
<suggest>实现带账户验证的电子邮件/密码认证</suggest>
<suggest>使用社交登录提供商（Google、GitHub 等）进行快速注册</suggest>
<suggest>同时实现电子邮件/密码和社交登录选项</suggest>
</follow_up>
</ask_followup_question>
